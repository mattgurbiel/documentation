"use strict";(self.webpackChunkpendle_documentation=self.webpackChunkpendle_documentation||[]).push([[7043],{3905:(e,t,n)=>{n.d(t,{Zo:()=>i,kt:()=>k});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=r.createContext({}),d=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},i=function(e){var t=d(e.components);return r.createElement(c.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,i=l(e,["components","mdxType","originalType","parentName"]),p=d(n),m=a,k=p["".concat(c,".").concat(m)]||p[m]||u[m]||o;return n?r.createElement(k,s(s({ref:t},i),{},{components:n})):r.createElement(k,s({ref:t},i))}));function k(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,s=new Array(o);s[0]=m;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l[p]="string"==typeof e?e:a,s[1]=l;for(var d=2;d<o;d++)s[d]=n[d];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},467:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>d});var r=n(7462),a=(n(7294),n(3905));const o={hide_table_of_contents:!0},s="Arbitrary Tokens with Pendle SDK Router",l={unversionedId:"Developers/SDK/ArbitraryTokens",id:"Developers/SDK/ArbitraryTokens",title:"Arbitrary Tokens with Pendle SDK Router",description:"How to use arbitrary tokens",source:"@site/docs/Developers/SDK/ArbitraryTokens.md",sourceDirName:"Developers/SDK",slug:"/Developers/SDK/ArbitraryTokens",permalink:"/Developers/SDK/ArbitraryTokens",draft:!1,tags:[],version:"current",frontMatter:{hide_table_of_contents:!0},sidebar:"myAutogeneratedSidebar",previous:{title:"Types and Functions",permalink:"/Developers/SDK/TypesAndFunctions"},next:{title:"RESTful API",permalink:"/Developers/API/RESTfulAPI"}},c={},d=[{value:"How to use arbitrary tokens",id:"how-to-use-arbitrary-tokens",level:2}],i={toc:d},p="wrapper";function u(e){let{components:t,...n}=e;return(0,a.kt)(p,(0,r.Z)({},i,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"arbitrary-tokens-with-pendle-sdk-router"},"Arbitrary Tokens with Pendle SDK Router"),(0,a.kt)("h2",{id:"how-to-use-arbitrary-tokens"},"How to use arbitrary tokens"),(0,a.kt)("p",null,"Normally, to interact with the Pendle contracts, a user must hold token that is either ",(0,a.kt)("em",{parentName:"p"},"input token")," or ",(0,a.kt)("em",{parentName:"p"},"output token")," (which can be obtained via ",(0,a.kt)("inlineCode",{parentName:"p"},"getTokensIn")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"getTokensOut")," methods of ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/pendle-finance/pendle-core-v2/blob/bc08c7aaf82c7975cf8591aef2fca3fe92a743b2/contracts/interfaces/IStandardizedYield.sol#L135-L143"},"IStandardizedYield contract"),"). "),(0,a.kt)("p",null,"Here is an example."),(0,a.kt)("p",null,"Suppose that we want to add liquidity to the ",(0,a.kt)("a",{parentName:"p",href:"https://app.pendle.finance/pro/pools/0xc374f7ec85f8c7de3207a10bb1978ba104bda3b2/zap/in?chain=ethereum"},"PT stETH\nPool"),"."),(0,a.kt)("p",null,"But this time we want to do it with 100 USDT."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { provider, testAccounts } from './sdk-doc-playground.mjs';\nimport { toAddress, BN, createERC20 } from '@pendle/sdk-v2';\nconst USDTAddress = toAddress('0xdac17f958d2ee523a2206206994597c13d831ec7');\nconst USDTContract = createERC20(USDTAddress, {\n    chainId: 1,\n    provider,\n    signer: testAccounts[0].wallet,\n});\nconst USDTDecimals = BigInt(await USDTContract.decimals());\n\nconst marketAddress = toAddress('0xc374f7ec85f8c7de3207a10bb1978ba104bda3b2');\nconst tokenInAddress = USDTAddress;\nconst amountTokenIn = BN.from(100n * 10n ** USDTDecimals);\nconst slippage = 0.2 / 100;\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { Router } from '@pendle/sdk-v2';\n\nconst router = Router.getRouter({\n    chainId: 1,\n    provider,\n    signer: testAccounts[0].wallet,\n});\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"// Remember to approve our router first!\nawait USDTContract.approve(router.address, amountTokenIn).then((tx) => tx?.wait());\n\ntry {\n    await router.addLiquiditySingleToken(marketAddress, tokenInAddress, amountTokenIn, slippage);\n    console.log('Success!');\n} catch (e) {\n    console.log('Error!');\n    console.log(e);\n}\n")),(0,a.kt)("p",null,"Output:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"Error!\nNoRouteFoundError: No route found to add liquidity from 0xdac17f958d2ee523a2206206994597c13d831ec7 to 0xc374f7ec85f8c7de3207a10bb1978ba104bda3b2\n    at Function.action (/home/darkkcyan/projects/pendle-sdk-core-v2-docs/node_modules/@pendle/sdk-v2/src/errors.ts:62:16)\n    at Router.addLiquiditySingleToken (/home/darkkcyan/projects/pendle-sdk-core-v2-docs/node_modules/@pendle/sdk-v2/src/entities/Router/BaseRouter.ts:461:37)\n    at processTicksAndRejections (node:internal/process/task_queues:96:5)\n    at async file:///home/darkkcyan/projects/pendle-sdk-core-v2-docs/temp-dir/docs/using-arbitary-tokens-with-router.mts:57:5 {\n  tokenInAddress: '0xdac17f958d2ee523a2206206994597c13d831ec7',\n  tokenOutAddress: '0xc374f7ec85f8c7de3207a10bb1978ba104bda3b2',\n  actionName: 'add liquidity'\n}\n")),(0,a.kt)("p",null,"We received the error, because USDT is not one of the SY token in PT stETH pool."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { MarketEntity } from '@pendle/sdk-v2';\nconst marketEntity = new MarketEntity(marketAddress, {\n    chainId: 1,\n    provider,\n    signer: testAccounts[0].wallet,\n});\nconst syEntity = await marketEntity.syEntity();\nconst tokensIn = await syEntity.getTokensIn();\nconst isIncluded = tokensIn.includes(USDTAddress);\n\nconsole.log({ tokensIn, USDTAddress, isIncluded });\n")),(0,a.kt)("p",null,"Output:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"{\n  tokensIn: [\n    '0x0000000000000000000000000000000000000000',\n    '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',\n    '0xae7ab96520de3a18e5e111b5eaab095312d7fe84',\n    '0x7f39c581f595b53c5cb19bd0b3f8da6c935e2ca0'\n  ],\n  USDTAddress: '0xdac17f958d2ee523a2206206994597c13d831ec7',\n  isIncluded: false\n}\n")),(0,a.kt)("p",null,"To overcome this, Pendle is using ",(0,a.kt)("a",{parentName:"p",href:"https://kyberswap.com"},"KyberSwap")," as the middleware aggregator to swap an arbitrary token into one of the input token, and then the swapped amount will be further used for the operation."),(0,a.kt)("p",null,"To enable this feature, you can do as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { KyberSwapAggregatorHelper } from '@pendle/sdk-v2';\nconst aggregatorHelper = new KyberSwapAggregatorHelper(router.address, {\n    chainId: 1,\n    provider,\n});\n\nconst routerWithAggregatorHelper = Router.getRouter({\n    chainId: 1,\n    provider,\n    signer: testAccounts[0].wallet,\n\n    aggregatorHelper, // <---- aggregator helper is passed here\n});\n")),(0,a.kt)("p",null,"Or, alternatively:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"const routerWithAggregatorHelper2 = Router.getRouterWithKyberAggregator({\n    chainId: 1,\n    provider,\n    signer: testAccounts[0].wallet,\n});\n")),(0,a.kt)("p",null,"Then you can call the method as normal:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"const tx = await routerWithAggregatorHelper.addLiquiditySingleToken(\n    marketAddress,\n    tokenInAddress,\n    amountTokenIn,\n    slippage\n);\n\nawait tx.wait();\n\nconst lpAmount = await marketEntity.balanceOf(testAccounts[0].address);\n\nconsole.log({ lpAmount });\n")),(0,a.kt)("p",null,"Output:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'{ lpAmount: BigNumber { value: "27526493643865688" } }\n')),(0,a.kt)("p",null,"You can even remove liquidity to a different token than output token of Standardized Yield! Let say we want to remove all the liquidity to USDC."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"const USDCAddress = toAddress('0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48');\nconst USDCContract = createERC20(USDCAddress, { chainId: 1, provider });\nawait marketEntity.approve(router.address, lpAmount).then((tx) => tx.wait());\nawait routerWithAggregatorHelper\n    .removeLiquiditySingleToken(marketAddress, lpAmount, USDCAddress, slippage)\n    .then((tx) => tx.wait());\n\nconst USDCBalance = await USDCContract.balanceOf(testAccounts[0].address);\nconsole.log(USDCBalance);\n")),(0,a.kt)("p",null,"Output:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'BigNumber { value: "1100711387" }\n')))}u.isMDXComponent=!0}}]);