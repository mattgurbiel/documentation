"use strict";(self.webpackChunkpendle_documentation=self.webpackChunkpendle_documentation||[]).push([[1652],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>h});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var c=n.createContext({}),s=function(e){var t=n.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},p=function(e){var t=s(e.components);return n.createElement(c.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,l=e.originalType,c=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),d=s(a),u=r,h=d["".concat(c,".").concat(u)]||d[u]||m[u]||l;return a?n.createElement(h,o(o({ref:t},p),{},{components:a})):n.createElement(h,o({ref:t},p))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=a.length,o=new Array(l);o[0]=u;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i[d]="string"==typeof e?e:r,o[1]=i;for(var s=2;s<l;s++)o[s]=a[s];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},2655:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>m,frontMatter:()=>l,metadata:()=>i,toc:()=>s});var n=a(7462),r=(a(7294),a(3905));const l={hide_table_of_contents:!0},o="WrappedContract",i={unversionedId:"Developers/SDK/WrappedContract",id:"Developers/SDK/WrappedContract",title:"WrappedContract",description:"Overview",source:"@site/docs/Developers/SDK/WrappedContract.md",sourceDirName:"Developers/SDK",slug:"/Developers/SDK/WrappedContract",permalink:"/Developers/SDK/WrappedContract",draft:!1,tags:[],version:"current",frontMatter:{hide_table_of_contents:!0},sidebar:"myAutogeneratedSidebar",previous:{title:"Getting Started",permalink:"/Developers/SDK/GettingStarted"},next:{title:"Router",permalink:"/Developers/SDK/Router"}},c={},s=[{value:"Overview",id:"overview",level:2},{value:"Usage",id:"usage",level:2},{value:"WrappedContract Creation",id:"wrappedcontract-creation",level:3},{value:"Basic Contract Interaction",id:"basic-contract-interaction",level:3},{value:"Multicall Support",id:"multicall-support",level:3},{value:"<code>multicallStatic</code> meta-class",id:"multicallstatic-meta-class",level:4},{value:"Initialize the <code>WrappedContract</code> with <code>Multicall</code>",id:"initialize-the-wrappedcontract-with-multicall",level:4},{value:"Pass <code>Multicall</code> to <code>multicallStatic</code> methods",id:"pass-multicall-to-multicallstatic-methods",level:4},{value:"<code>metaCall</code> meta class",id:"metacall-meta-class",level:4},{value:"Quick Example",id:"quick-example",level:2}],p={toc:s},d="wrapper";function m(e){let{components:t,...a}=e;return(0,r.kt)(d,(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"wrappedcontract"},"WrappedContract"),(0,r.kt)("h2",{id:"overview"},"Overview"),(0,r.kt)("p",null,"Pendle SDK is built on top of ",(0,r.kt)("a",{parentName:"p",href:"https://docs.ethers.io/v5/"},"Ethers"),". While being versatile, Ethers lacks some specific functionalities, such as calling contracts with multicall and catching our contract\u2019s errors. Using Ethers\u2019 Contract objects directly is often less reusable, as sometimes we want to estimate the consumed gas, or get the result instead of making a transaction, but with the same logic as making the transaction. To solve these problems, we decided to make wrap Ethers\u2019 Contract object to create a high-level object, making the contract interaction process more convenient. "),(0,r.kt)("h2",{id:"usage"},"Usage"),(0,r.kt)("h3",{id:"wrappedcontract-creation"},"WrappedContract Creation"),(0,r.kt)("p",null,"To create a ",(0,r.kt)("inlineCode",{parentName:"p"},"WrappedContract"),", use the function ",(0,r.kt)("inlineCode",{parentName:"p"},"createContractObject"),". In the following example, contract objects for the USDC token."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { createContractObject, toAddress } from '@pendle/sdk-v2';\nimport { PendleERC20, PendleERC20ABI } from '@pendle/sdk-v2';\nimport { providers, Wallet } from 'ethers';\n\nconst USDCAddress = toAddress('0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48');\nconst provider = new providers.StaticJsonRpcProvider();\nconst signer = Wallet.createRandom().connect(provider);\nconst chainId = 1;\n\nconst readonlyWrappedContract = createContractObject<PendleERC20>(USDCAddress, PendleERC20ABI, { provider }); \nconst readWriteWrappedContract = createContractObject<PendleERC20>(USDCAddress, PendleERC20ABI, { signer });\n")),(0,r.kt)("p",null,"This function accepts a type parameter ",(0,r.kt)("inlineCode",{parentName:"p"},"C"),", which is the generated contract's typechain type. Next is the contract\u2019s addresses, and its ABI. The final parameter is the configuration."),(0,r.kt)("p",null,"The configuration has the ",(0,r.kt)("inlineCode",{parentName:"p"},"signer")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"provider")," similar to the configuration of ",(0,r.kt)("inlineCode",{parentName:"p"},"PendleEntity"),". See ",(0,r.kt)("a",{parentName:"p",href:"/Developers/SDK/ERC20Interaction"},"ERC20 contract interaction tutorial with Pendle SDK"),", as well as the ",(0,r.kt)("inlineCode",{parentName:"p"},"NetworkConnection")," type in ",(0,r.kt)("a",{parentName:"p",href:"/Developers/SDK/TypesAndFunctions"},"Types and Functions"),"."),(0,r.kt)("p",null,"By default, this function returns ",(0,r.kt)("inlineCode",{parentName:"p"},"WrappedContract<C>"),", but it can also return Ethersj.s' Contract, if ",(0,r.kt)("inlineCode",{parentName:"p"},"doWrap: false")," is passed to the configuration."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// Will have type PendleERC20 instead of WrappedContract<PendleERC20>\nconst ethersJsContract: PendleERC20 = createContractObject<PendleERC20>(USDCAddress, PendleERC20ABI, { signer, doWrap: false });\n")),(0,r.kt)("h3",{id:"basic-contract-interaction"},"Basic Contract Interaction"),(0,r.kt)("p",null,"A ",(0,r.kt)("inlineCode",{parentName:"p"},"WrappedContract")," object also has ",(0,r.kt)("em",{parentName:"p"},"the same")," meta classes as ethersjs\u2019 Contract, and they can be used the same way! Here is an example for the read function."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { Address, BigNumberish, ContractLike } from '@pendle/sdk-v2';\n\nasync function exampleReadFunctions(contract: ContractLike<PendleERC20>, user1: Address, user2: Address) {\n  // call methods right from the contract object\n  const user1Balance = (await contract.balanceOf(user1)).toString();\n  const symbol = await contract.symbol();\n  const name = await contract.name();\n  \n  // call static\n  const user2Balance = (await contract.callStatic.balanceOf(user2)).toString();\n\n  // estimate gas\n  const allowanceGasUsed = (await contract.estimateGas.allowance(user1, user2)).toString();\n  return {\n    user1Balance,\n    user2Balance,\n    symbol,\n    name,\n    allowanceGasUsed, \n  };\n}\n")),(0,r.kt)("p",null,"To see the functions in action, we can use the following addresses taken from the ",(0,r.kt)("a",{parentName:"p",href:"https://etherscan.io/token/0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48#balances"},"top USDC holder page")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const user1 = toAddress('0x0a59649758aa4d66e25f08dd01271e891fe52199');\nconst user2 = toAddress('0xf977814e90da44bfa03b6295a0616a897441acec');\n\n// works with both Ethersjs' Contract and WrappedContract\n\ntry {\n  console.log('readonly wrapped contract', await exampleReadFunctions(readonlyWrappedContract, user1, user2));\n  console.log('read write wrapped contract', await exampleReadFunctions(readWriteWrappedContract, user1, user2));\n  console.log('ehtersjs contract', await exampleReadFunctions(ethersJsContract, user1, user2));\n} catch (e) {\n  console.error(e);\n}\n")),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"readonly wrapped contract {\n  user1Balance: '431722858735941',\n  user2Balance: '6390000000',\n  symbol: 'USDC',\n  name: 'USD Coin',\n  allowanceGasUsed: '31726'\n}\nread write wrapped contract {\n  user1Balance: '431722858735941',\n  user2Balance: '6390000000',\n  symbol: 'USDC',\n  name: 'USD Coin',\n  allowanceGasUsed: '31726'\n}\nehtersjs contract {\n  user1Balance: '431722858735941',\n  user2Balance: '6390000000',\n  symbol: 'USDC',\n  name: 'USD Coin',\n  allowanceGasUsed: '31726'\n}\n")),(0,r.kt)("p",null,"The write function can also be done in the same way. But please do not run them if you do not intend to in this example!"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"async function exampleWriteFunctions(contract: ContractLike<PendleERC20>, receiver: Address, amount: BigNumberish) {\n  // functions\n  await contract.functions.approve(receiver, amount);\n\n  // call methods right from the contract object\n  await contract.transfer(receiver, amount);\n}\n\n// exampleWriteFunctions(readWriteWrappedContract, user1, tesAmount);\n// exampleWriteFunctions(ethersJsContract, user1, testAmount);\n")),(0,r.kt)("p",null,"Though the interfaces are the same, there is a key difference: when there is an error, Pendle SDK will throw a custom error, especially for Pendle Contracts. See ",(0,r.kt)("a",{parentName:"p",href:"/Developers/SDK/ErrorHandling"},"Error handling"),"."),(0,r.kt)("h3",{id:"multicall-support"},"Multicall Support"),(0,r.kt)("h4",{id:"multicallstatic-meta-class"},(0,r.kt)("inlineCode",{parentName:"h4"},"multicallStatic")," meta-class"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { Multicall, MulticallOverrides } from '@pendle/sdk-v2';\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"WrappedContract")," object has an additional meta-class called ",(0,r.kt)("inlineCode",{parentName:"p"},"multicallStatic"),". It has the same function as the ",(0,r.kt)("inlineCode",{parentName:"p"},"callStatic")," meta-class, but the signature is a bit different."),(0,r.kt)("p",null,"The signature of a ",(0,r.kt)("inlineCode",{parentName:"p"},"callStatic")," method will have the following form:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"callStaticMethod(arg1, arg2, ..., overrides?: Override): Promise<Result>;\n")),(0,r.kt)("p",null,"The signature of a ",(0,r.kt)("inlineCode",{parentName:"p"},"multicallStatic")," method will have the following form instead:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"multicallStaticMethod(arg1, arg2, ..., multicallStaticParams?: MulticallStaticParams): Promise<Result>;\n")),(0,r.kt)("p",null,"Where"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"type MulticallStaticParams = {\n  multicall?: Multicall;\n  overrides?: MulticallOverrides;\n};\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"multicallStatic")," is guaranteed to work ",(0,r.kt)("strong",{parentName:"p"},"correctly"),". If ",(0,r.kt)("inlineCode",{parentName:"p"},"multicall")," is not specified, the methods of this meta-class will act as ",(0,r.kt)("inlineCode",{parentName:"p"},"callStatic"),"."),(0,r.kt)("p",null,"Similarly to a ",(0,r.kt)("inlineCode",{parentName:"p"},"PendleEntity"),", like our ",(0,r.kt)("inlineCode",{parentName:"p"},"ERC20")," entity (see ",(0,r.kt)("a",{parentName:"p",href:"/Developers/SDK/ERC20Interaction"},"ERC20 contract interaction tutorial with Pendle SDK"),"), there are two way to use ",(0,r.kt)("inlineCode",{parentName:"p"},"multicall"),"."),(0,r.kt)("h4",{id:"initialize-the-wrappedcontract-with-multicall"},"Initialize the ",(0,r.kt)("inlineCode",{parentName:"h4"},"WrappedContract")," with ",(0,r.kt)("inlineCode",{parentName:"h4"},"Multicall")),(0,r.kt)("p",null,"Pass the ",(0,r.kt)("inlineCode",{parentName:"p"},"Multicall")," instance to the configuration of ",(0,r.kt)("inlineCode",{parentName:"p"},"createContractObject"),". Then use ",(0,r.kt)("inlineCode",{parentName:"p"},"multicallStatic")," to have the ",(0,r.kt)("em",{parentName:"p"},"batching")," effects of multicall."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"{\n  async function wrappedContractWithMulticall(contractAddress: Address, userAddress: Address) {\n    const multicall = new Multicall({ chainId, provider });\n    const contract = createContractObject<PendleERC20>(contractAddress, PendleERC20ABI, {\n      provider,\n      multicall  // pass it here\n    });\n    \n    const [name, symbol, decimals, userBalance] = await Promise.all([\n      contract.multicallStatic.name(),\n      contract.multicallStatic.symbol(),\n      contract.multicallStatic.decimals(),\n      contract.multicallStatic.balanceOf(userAddress),\n    ]);\n    return { name, symbol, decimals, userBalance: userBalance.toString()};\n  }\n\n  try {\n    console.log(await wrappedContractWithMulticall(USDCAddress, user1));\n  } catch (e) {\n    console.error(e);\n  }\n}\n")),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"{\n  name: 'USD Coin',\n  symbol: 'USDC',\n  decimals: 6,\n  userBalance: '431722858735941'\n}\n")),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("inlineCode",{parentName:"p"},"Promise.all")," should be used to have the ",(0,r.kt)("em",{parentName:"p"},"batching")," effect.")),(0,r.kt)("h4",{id:"pass-multicall-to-multicallstatic-methods"},"Pass ",(0,r.kt)("inlineCode",{parentName:"h4"},"Multicall")," to ",(0,r.kt)("inlineCode",{parentName:"h4"},"multicallStatic")," methods"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Multicall")," instance can also be passed to the calling methods."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"{\n  async function wrappedContractWithMulticall(contractAddress: Address, userAddress: Address) {\n    const multicall = new Multicall({ chainId, provider });\n    const contract = createContractObject<PendleERC20>(contractAddress, PendleERC20ABI, {\n      provider,\n    });\n    \n    const [name, symbol, decimals, userBalance] = await Promise.all([\n      contract.multicallStatic.name({multicall}),\n      contract.multicallStatic.symbol({multicall}),\n      contract.multicallStatic.decimals({multicall}),\n      contract.multicallStatic.balanceOf(userAddress, {multicall}),\n    ]);\n    return { name, symbol, decimals, userBalance: userBalance.toString()};\n  }\n\n  try {\n    console.log(await wrappedContractWithMulticall(USDCAddress, user1));\n  } catch (e) {\n      console.error(e);\n  }\n}\n")),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"{\n  name: 'USD Coin',\n  symbol: 'USDC',\n  decimals: 6,\n  userBalance: '431722858735941'\n}\n")),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"If the contract is already initialized with ",(0,r.kt)("inlineCode",{parentName:"p"},"Multicall"),", but another ",(0,r.kt)("inlineCode",{parentName:"p"},"Multicall")," instance is passed into the ",(0,r.kt)("inlineCode",{parentName:"p"},"multicallStatic")," methods, ",(0,r.kt)("strong",{parentName:"p"},"the passed one will be used"),". So one ",(0,r.kt)("inlineCode",{parentName:"p"},"WrappedContract")," instance can be used with different ",(0,r.kt)("inlineCode",{parentName:"p"},"Multicall")," instance in different contexts."),(0,r.kt)("p",{parentName:"admonition"},"We encourage using the ",(0,r.kt)("em",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"em"},"Multicall")," to ",(0,r.kt)("inlineCode",{parentName:"em"},"multicallStatic")," methods")," style for developing new functions, as the contract can always be called with the user's defined ",(0,r.kt)("inlineCode",{parentName:"p"},"Multicall")," in different contexts.")),(0,r.kt)("h4",{id:"metacall-meta-class"},(0,r.kt)("inlineCode",{parentName:"h4"},"metaCall")," meta class"),(0,r.kt)("p",null,"Similar to an ERC20 entity, all PendleEntity classes will support calling write functions with meta-methods. See ",(0,r.kt)("a",{parentName:"p",href:"/Developers/SDK/ERC20Interaction"},"ERC20 contract interaction tutorial with Pendle SDK"),", the Meta-methods section for examples."),(0,r.kt)("p",null,"To aid the development of these write functions, ",(0,r.kt)("inlineCode",{parentName:"p"},"WrappedContract")," methods can also be called directly with meta-methods via the meta-class ",(0,r.kt)("inlineCode",{parentName:"p"},"metaCall"),". "),(0,r.kt)("p",null,"The methods of ",(0,r.kt)("inlineCode",{parentName:"p"},"metaCall")," will have the following signature:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"contract.metaCall.methodName(arg1, arg2, ..., metaMethodType?: MetaMethodExtraParam): MetaMethodReturnType;\n")),(0,r.kt)("p",null,"Where"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"type MetaMethodExtraParams<T extends MetaMethodType = 'send'> = MulticallStaticParams & {\n  method?: T;\n  gasLimitBufferingPercent?: number;\n};\n\ntype MetaMethodType = 'send' | 'callStatic' | 'estimateGas' | 'meta-method' | 'multicallStatic' | 'populateTransaction' | 'extractParams';\n")),(0,r.kt)("p",null,"And ",(0,r.kt)("inlineCode",{parentName:"p"},"MetaMethodReturnType")," is a helper type that will be defined for each ",(0,r.kt)("inlineCode",{parentName:"p"},"MetaMethodType"),"."),(0,r.kt)("p",null,"Here is a table for the actual return type for each ",(0,r.kt)("inlineCode",{parentName:"p"},"MetaMethodType"),"."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"MetaMethodType"),(0,r.kt)("th",{parentName:"tr",align:null},"The meta-class to be mimicked"),(0,r.kt)("th",{parentName:"tr",align:null},"Specific return type"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"send")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"contract.functions")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Promise<ContractTransaction>")," for write-methods. ",(0,r.kt)("inlineCode",{parentName:"td"},"Promise<R>")," for read-methods.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"callStatic")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"contract.callStatic")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Promise<R>"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"estimateGas")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"contract.estimateGas")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Promise<BigNumber>"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"multicallStatic")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"contract.multicallStatic")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Promise<R>"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"populateTransaction")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"contract.populateTransaction")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Promise<PopulatedTransaction>"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"extractParams")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"contract.interface.decodeFunctionData")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Promise<any[]>"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"meta-method")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"contract.metaCall")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"ContractMetaMethod"))))),(0,r.kt)("p",null,"Here ",(0,r.kt)("inlineCode",{parentName:"p"},"Promise<R>")," is the return type of the contract methods. For example, for ERC20 contract, ",(0,r.kt)("inlineCode",{parentName:"p"},"balanceOf")," will return ",(0,r.kt)("inlineCode",{parentName:"p"},"Promise<BigNumber>"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"name()")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"symbol()")," will return ",(0,r.kt)("inlineCode",{parentName:"p"},"Promise<string>"),". ",(0,r.kt)("inlineCode",{parentName:"p"},"Promise<any[]>")," is the return type of params extraction. For example, for ",(0,r.kt)("inlineCode",{parentName:"p"},"transfer")," method of a ERC20 contract, the return type will be ",(0,r.kt)("inlineCode",{parentName:"p"},"Promise<[to: string, amount: BigNumberish, overrides?: CallOverrides | undefined]>"),"."),(0,r.kt)("p",null,"When the ",(0,r.kt)("inlineCode",{parentName:"p"},"metaMethodType")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"undefined"),", the method act like ",(0,r.kt)("inlineCode",{parentName:"p"},"send.")),(0,r.kt)("p",null,"See ",(0,r.kt)("a",{parentName:"p",href:"http://playground.pendle.finance/sdk-docs/types/MetaMethodReturnType.html"},(0,r.kt)("inlineCode",{parentName:"a"},"type MetaMethodReturnType"))," for a more formal specification of ",(0,r.kt)("inlineCode",{parentName:"p"},"MetaMethodReturnType"),", and ",(0,r.kt)("a",{parentName:"p",href:"http://playground.pendle.finance/sdk-docs/classes/ContractMetaMethod.html"},(0,r.kt)("inlineCode",{parentName:"a"},"class ContractMetaMethod"))," for additional features of ",(0,r.kt)("inlineCode",{parentName:"p"},"ContractMetaMethod"),"."),(0,r.kt)("h2",{id:"quick-example"},"Quick Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { WrappedContract } from '@pendle/sdk-v2';\n\nasync function metaCallExample(contract: WrappedContract<PendleERC20>) {\n  const user1 = toAddress('0x0a59649758aa4d66e25f08dd01271e891fe52199'), user2 = toAddress('0xf977814e90da44bfa03b6295a0616a897441acec');\n  const amount = '100';\n\n    // send example\n  await contract.metaCall.approve(user1, amount, { method: 'send' });\n  await contract.metaCall.approve(user1, amount);  // do the same as the above.\n\n  // call static example\n  const allowance = await contract.metaCall.allowance(user1, user2, { method: 'callStatic' });\n\n  // multicallStatic example\n  const [name, symbol, decimals, totalSuply] = await Promise.all([\n    contract.metaCall.name({ method: 'multicallStatic'}),\n    contract.metaCall.symbol({ method: 'multicallStatic' }),\n    contract.metaCall.decimals({ method: 'multicallStatic' }),\n    contract.metaCall.totalSupply({ method: 'multicallStatic' })\n  ]);\n\n  // estimateGas example\n  const transferGasUsed = await contract.metaCall.transfer(user1, amount, { method: 'estimateGas' });\n\n  // populateTransaction example\n  const transferPopulatedTransaction = await contract.metaCall.transfer(user1, amount, { method: 'populateTransaction' });\n\n  // extractParams example\n  const transferParams = await contract.metaCall.transfer(user1, amount, { method: 'extractParams' });\n  \n  // meta-method example\n\n  const transferMetaMethod = await contract.metaCall.transfer(user1, amount, { method: 'meta-method' });\n  {\n    // use with callStatic.\n    const remaning = await transferMetaMethod.callStatic();\n    // use with estimateGas.\n    const gasUsed = await transferMetaMethod.estimateGas();\n    await transferMetaMethod.send();\n    // can also be used to send again.\n    await transferMetaMethod.send();\n  }\n}\n")))}m.isMDXComponent=!0}}]);